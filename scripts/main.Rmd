---
output:
  pdf_document: default
  html_document: default
---
```{r, echo=FALSE, include=FALSE}
#install.packages("dplyr")
#install.packages("ggplot2")
#install.packages("viridis")
#install.packages("corrplot")
#install.packages("tidymodels")
#install.packages("rpart.plot")
#install.packages("rgl")
#install.packages("readxl")
#install.packages("nortest")
library(dplyr)
library(ggplot2)
library(viridis)
library(corrplot)
library(tidymodels)
library(rpart.plot)
library(rgl)
library(readxl)
library(nortest)
```

\vspace*{1cm}

\begin{center}
  \textbf{Statystyka matematyczna i ekonometria}


  \vspace{0.5cm}

  Projekt - Auto Sprzedam

            
  \vspace{2cm}

  \textbf{Autorzy} \\ 
  Anna Kalitka (255445) \\
  Antoni Bezdzietny (249327)

  \vfill
            
  Projekt zaliczeniowy\\
  Laboratorium, lato 2023/24
  
  \vspace{2cm}
  
\end{center}            


# I - Opis bazy danych
  Wybrana została baza danych **AutoSprzedam**. Baza pochodzi z zasobów ePortalu.
  
  
## Zawartość bazy danych
  Baza danych składa się z 41034 rekordów, zawierających szczegółowe dane dotyczące sprzedaży samochodów m.in.

  <p style="text-align:center;">
  | Kolumna            | Typ danych | Opis                                                                                      |
  |--------------------|------------|-------------------------------------------------------------------------------------------|
  | NrOferty           | int        | Numer oferty sprzedaży samochodu.                                                         |
  | CenaPLN            | string     | Cena samochodu wyrażona w polskich złotych (PLN).                                         |
  | KM                 | int        | Liczba koni mechanicznych samochodu.                                                      |
  | Marka              | string     | Marka samochodu.                                                                          |
  | Model              | string     | Model samochodu.                                                                          |
  | LiczbaDrzwi        | string     | Liczba drzwi w samochodzie.                                                               |
  | PojemnoscSkokowa   | int        | Pojemność skokowa silnika wyrażona w centymetrach sześciennych (cm³).                     |
  | PrzebiegKm         | int        | Przebieg samochodu wyrażony w kilometrach.                                                |
  | RodzajPaliwa       | string     | Rodzaj paliwa używanego przez samochód (benzyna, diesel, hybryda, elektryczny itp.).      |
  | RokProdukcji       | int        | Rok produkcji samochodu.                                                                  |
  | Kolor              | string     | Kolor samochodu.                                                                          |
  | KrajPochodzenia    | string     | Kraj pochodzenia samochodu.                                                               |
  | PojazdUszkodzony   | string     | Informacja czy pojazd jest uszkodzony (Tak/Nie).                                          |
  | SkrzyniaBiegow     | string     | Typ skrzyni biegów w samochodzie (manualna, automatyczna).                                |
  </p>
  

## Prezentacja bazy danych
```{r}
# Wczytanie bazy danych
database = read.csv("../database/AutoSprzedam.dat", sep = "\t", dec = ',');

cat("Liczba rekordów:", nrow(database), ", liczba kolumn:", ncol(database), "\n")

N = 5;
cat("-", "Przykład ", N, "pierwszych rekordów.\n")
head(database, N)

cat("- ", "Przykład ", N, "ostatnich rekordów.\n")
tail(database, N)
```

## Przygotowanie bazy danych
  Przed przejściem do dalszej pracy z bazą danych postanowiono wprowadzenie zmian w jej strukturze, 
  których celem jest uproszczenie przyszłych prac z danymi.

### Pole - *SkrzyniaBiegow*
  W bazie występują 3 rodzaje typów skrzyni biegów: *półautomatyczna/sekwencyjna*, *manualna* oraz *automatyczna*.
  Udział typu *półautomatyczna/sekwencyjna* w całej bazie wynosi 1,5%.
  
  W związku z niewielkim udziałem ze skrzynią *półautomatyczna/sekwencyjna*, typ ten został usunięty z bazy. 
  Dzięki czemu możliwe jest przekształcenie kolumny *SkrzyniaBiegow* (char), na *SkrzyniaBiegowManualna* (bool).
```{r}
gear_box_summary = database %>% group_by(database$SkrzyniaBiegow) %>% summarise(liczba = n());
gear_box_summary
cat("Udział pojazdów ze skrzynią biegów typu 'półautomatyczna/sekwencyjna'", sum(gear_box_summary[3,2])/sum(gear_box_summary[,2])*100, "%.");

# Remove cars with database$SkrzyniaBiegow == 'półautomatyczna/sekwencyjna'
database = database[database$SkrzyniaBiegow != "półautomatyczna/sekwencyjna",];

# Cast to logical value
database$SkrzyniaBiegow = database$SkrzyniaBiegow == "manualna";
colnames(database)[14] = "SkrzyniaBiegowManualna";
```

### Pole *PojazdUszkodzony*
  Domyślnym typem danych dla pola *PojazdUszkodzony* jest (char). Zmienna jest typem logicznym (TAK/NIE). 
  W związku z powyższym kolumna *PojazdUszkodzony* została przekształcona to typu *bool*.
```{r}
database$PojazdUszkodzony = database$PojazdUszkodzony == "Tak"
```

## Prezentacja bazy danych - po wprowadzonych zmianach
```{r}
N = 5;
cat("-", "Przykład ", N, "pierwszych rekordów.\n")
head(database, N)

cat("- ", "Przykład ", N, "ostatnich rekordów.\n")
tail(database, N)
```


# Wyznaczenie podstawowych statystyk

## Pole *CenaPLN*
  Kolumna zawiera informacje o cenie po jakie asmochody zostału sprzedane w PLN.
  

### Dane przed eliminacją danych odstających
```{r, message = FALSE}
summarise(database,
  srednia = mean(CenaPLN),
  mediana = median(CenaPLN),
  wariancja = var(CenaPLN),
  odchylenieStd = sd(CenaPLN),
  max = max(CenaPLN),
  min = min(CenaPLN),
)

ggplot(data=database) + geom_histogram(aes(x=CenaPLN), bins = 50) + ggtitle("Histogram dla cen sprzedaży");

ggplot(data=database) + geom_boxplot(aes(x=CenaPLN)) + ggtitle("Wykres pudełko-wąsy dla cen sprzedaży");
```

# IV -  Obserwacje odstające
Obserwacja odstająca, element odstający  – obserwacja relatywnie odległa od pozostałych elementów próby. Innymi słowy, posiadająca nietypową wartość zmiennej niezależnej (objaśniającej) lub nietypowe wartości obydwu zmiennych – zależnej (objaśnianej) i objaśniającej (objaśniających w analizie regresji wielokrotnej). 

## Redukcja danych odstających zgodnie z regułą 3 sigma
Redukcja danych zgodnie z regułą 3 sigma. 

Identyfikacja danych odstających za pomocą reguły trzech sigm:

1. Obliczenie średniej ($\mu$): Najpierw oblicza się średnią dla danego zbioru danych.

2. Obliczenie odchylenia standardowego ($\sigma$): Następnie oblicza się odchylenie standardowe, które mierzy, jak bardzo dane rozpraszają się wokół średniej.

3. Ustalenie zakresu trzech sigm: Wartości, które znajdują się poza zakresem trzech sigm ($\mu$ ± 3$\sigma$), są uznawane za dane odstające.

```{r, message = FALSE}
mean_price = mean(database$CenaPLN);
sd_price   = sd(database$CenaPLN);

lower_bound <- mean_price - 3 * sd_price;
upper_bound <- mean_price + 3 * sd_price;

cat("Wyznacznowe granice metodą 3 sigma \n")
cat("Dolna granica ", lower_bound, ", górna granica ", upper_bound, "\n");
cat("Dolna granica wykracza poza osiągane wartości kwot sprzedaży (ujemna wartość). \n")

upper_price_example = database[which(database$CenaPLN >= upper_bound),];
head(upper_price_example[order(upper_price_example$CenaPLN, decreasing = TRUE),])

database = database[database$CenaPLN >= lower_bound & database$CenaPLN <= upper_bound,]
```

## Redukcja danych odstających regułą odstępu międzykwartylowgo
Metoda redukcji, polega na wykrywaniu i usuwaniu wartości odstających z zestawu danych. Metoda ta opiera się na kwartylach i rozstępie międzykwartylowym.

1. Wyznaczenie *Q1* (pierwszy kwartyl) oraz *Q3* (trzeci kwartyl)

2. Wyznaczenie odstępu międzykwartylowego *IQR = Q3 - Q1*

3. Wyznaczenie dolnej *Q1 - 1.5 x IQR* oraz górnej *Q1 + 1.5 x IQR* granicy.

```{r, message = FALSE}
Q1 = quantile(database$PrzebiegKm, 0.25);
Q3 = quantile(database$PrzebiegKm, 0.75);
IQR = Q3-Q1;
lower_bound = Q1 - 1.5*IQR #mniejsze niż
upper_bound = Q3 + 1.5*IQR #większe niż 

cat("Wyznacznowe granice metodą odstępu międzykwartylowego sigma \n")
cat("Dolna granica ", lower_bound, ", górna granica ", upper_bound, "\n");
cat("Dolna granica wykracza poza osiągane wartości kwot sprzedaży (ujemna wartość). \n")

database = database[database$PrzebiegKm >= lower_bound & database$PrzebiegKm <= upper_bound,]
```

```{r, message = FALSE}
database %>% group_by(Marka) %>% summarise(liczbaSprzedanych = n(), 
                                                    sredniaCena = mean(CenaPLN),
                                                    medianaCena = median(CenaPLN))
```

### Dane po eliminacją danych odstających
```{r, message = FALSE}
summarise(database,
  srednia = mean(CenaPLN),
  mediana = median(CenaPLN),
  wariancja = var(CenaPLN),
  odchylenieStd = sd(CenaPLN),
  max = max(CenaPLN),
  min = min(CenaPLN),
)

ggplot(data=database) + geom_histogram(aes(x=CenaPLN), bins = 50) + ggtitle("Histogram dla cen sprzedaży");

ggplot(data=database) + geom_boxplot(aes(x=CenaPLN)) + ggtitle("Wykres pudełko-wąsy dla cen sprzedaży");

ggplot(data=database, aes(sample = CenaPLN)) + stat_qq() + stat_qq_line(colour="red") + ylab("Kwantyl Teoretyczny") + xlab("Kwantyl Empiryczny") + 
  ggtitle("Wykres QQ dla cen sprzedaży") + theme(axis.text.x = element_blank(), axis.text.y = element_blank()) ;
```


```{r, message = FALSE}
fuelType = database %>% group_by(database$RodzajPaliwa) %>% summarise(liczba = n());
colnames(fuelType) = c("FuelType", "Count");
fuelType = fuelType[order(fuelType$Count, decreasing = TRUE),]
fuelType

ggplot(fuelType, aes(x="", y=Count, fill=FuelType)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) + theme_void();
```
## Liczba koni mechanicznych samochodu


```{r, message = FALSE}
summarise(database,
  srednia = mean(KM),
  mediana = median(KM),
  wariancja = var(KM),
  odchylenieStd = sd(KM),
  max = max(KM),
  min = min(KM),
)

upper_price_example = database[which(database$CenaPLN >= upper_bound),];
head(upper_price_example[order(upper_price_example$CenaPLN, decreasing = TRUE),])

ggplot(data=database)+ geom_histogram(aes(x=KM), binwidth = 20) + ggtitle("Histogram dla KM")


```

# V - Wyznaczanie prawdopodobieństw dla zmiennej

## Rozkłady dyskretne

### Dwumianowy
```{r}
#Generowanie próbki
set.seed(42)
N <- 1000
n <- 20
p <- 0.4
X <- rbinom(N, n, p)

#Prawdopodobieństwa
pbinom(8, n, p) - pbinom(7, n, p) # P(X=8) p. punktowe
pbinom(10, n, p) # P(X<=10) p. przedziałowe

#Wykres gęstości
a <- seq(0, n, by = 1)
b <- dbinom(a, n, p)
plot(a,b, type="h")

#Wykres dystrybuanty
a <- seq(0, n, by = 1)
b <- pbinom(a, n, p)
plot(a,b)
```
### Rozkład Poissona
```{r}
#Generowanie próbki
N <- 1000
lambda <- 200
X <- rpois(N, lambda)

#Prawdopodobieństwa
ppois(190, lambda) - ppois(189, lambda) # P(X=190)
ppois(190, lambda) #(P<=190)

#Wykres gęstości
a <- seq(min(X), max(X), by = 1)
b <- dpois(a, lambda)
plot(a,b, type="h")

#Wykres dystrybuanty
a <- seq(min(X), max(X), by = 1)
b <- ppois(a, lambda)
plot(a,b)
```

## Rozkłady ciągłe 

### Rozkład normalny
```{r}
#Generowanie próbki
N <- 1000
mu <- 7 # średnia
sigma <- 10 # odchylenie standardowe
X <- rnorm(N, mu, sigma)

#Prawdopodobieństwa
#Prawd. punktowe w rozkładzie ciągłym = 0
pnorm(10, mu, sigma) # P(X<=10) p. przedziałowe

#Wykres gęstości
a <- seq(min(X), max(X), by = 0.5)
b <- dnorm(a, mu, sigma)
plot(a,b, type="h")

#Wykres dystrybuanty
a <- seq(min(X), max(X), by = 0.5)
b <- pnorm(a, mu, sigma)
plot(a,b)
```


### Rozkład Beta
```{r}
#Generowanie próbki
N <- 1000
alpha <- 0.5
beta <- 0.5
X <- rbeta(N, alpha, beta)

#Prawdopodobieństwa
#Prawd. punktowe w rozkładzie ciągłym = 0
pbeta(0.7, alpha, beta) # P(X<=0.7) p. przedziałowe

#Wykres gęstości
a <- seq(0, 1, by = 0.02)
b <- dbeta(a, alpha, beta)
plot(a,b, type="h")

#Wykres dystrybuanty
a <- seq(0, 1, by = 0.02)
b <- pbeta(a, alpha, beta)
plot(a,b)
```


# VI - Budowa macierzy z bazy danych
Do zbudowanie macierzy wykorzystano wszystkie dostępne numeryczne dane tj. *CenaPLN*, *KM*, *PrzebiegKm*, *RokProdukcji*, *PojemnoscSkokowa*. 
Dzięki temu możliwe jest wyznaczenie macierzy korelacji pomiędzy danymi.
```{r, message = FALSE}
# Select data
vi_database = select(filter(database, PojazdUszkodzony==FALSE & SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "KM", "PrzebiegKm", "RokProdukcji", "PojemnoscSkokowa"))

#Display head
head(vi_database) 

# Dimension
vi_dim <- dim(vi_database);
cat("Rozmiar macierzy:", vi_dim[1], "x", vi_dim[2]);

# Columns mean
vi_means = round(colMeans(vi_database), 3);
cat(paste(names(vi_means), vi_means, sep = " : ", collapse = ",\n"))

# Correlation 
vi_corr_matrix = cor(vi_database);
print(vi_corr_matrix)
corrplot(vi_corr_matrix, order = "hclust", 
         tl.col = "black", tl.srt = 45)
```
Jak można zaobserwować:
- *CenaPLN* skorelowana jest z *RokProdukcji* (silnie), *KM*, *PojemnoscSkokowa* oraz odwrotnie z *PrzebiegKM*,  
- *PojemnoscSkokowa* jest silnie skorelowana z ilością *KM* (większa pojemność -> więcej KM),
- *PrzebiegKM* jest odwrotnie skorelowany z *RokProdukcji* (starszy samochód -> większy przebieg).

# VII - Przedziały ufności
W tej sekcji przedstawione zostaną badania określające przedziały ufności z różnym stopniem 'zaufania'.
Oznacza to, że jeśli grupa badana była zgromadzona w sposób losowy to rzeczywisty parametr
populacji z z określonym stopniem 'zaufania' znajduje się w tym przedziale.

## Zmienna numeryczna
W celu określnenia przedziałów ufności zmiennej numerycznej wybrano cechę *CenaPLN*.
Przedział ufności dla średniej:
```{r, message = FALSE}
# Meta data 
# Confidence level 0.9, 0.95, 0.99
confidence_level = c(0.9, 0.95, 0.99);

# Basic data
vii_price_mean = mean(database$CenaPLN);
vii_price_sd = sd(database$CenaPLN);
n = length(database$CenaPLN);

# Mean confidence function
mean_confidence <- function(mean, sd, n, confidence_level) {
  alpha = 1 - confidence_level;
  offset = qnorm(1 - alpha / 2) * sd / sqrt(n);
  lower_bound = mean - offset;
  upper_bound = mean + offset;
  return(c(lower_bound, upper_bound));
};

# Calculate confidence
mean_confidence_intervals = sapply(confidence_level, function(conf_level) {
  mean_confidence(vii_price_mean, vii_price_sd, n, conf_level)
});

# Create matrix
mean_confidence_intervals = t(mean_confidence_intervals);
rownames(mean_confidence_intervals) = paste0("Poziom ufności: ", confidence_level);
colnames(mean_confidence_intervals) = c("Dolny przedział", "Górny przedział");

# Display
print("Przedziały ufności średniej dla różnych poziomów ufności:");
print(mean_confidence_intervals);
```

Przedział ufności dla wariancji:
```{r, message = FALSE}
# Meta data 
# Confidence level 0.9, 0.95, 0.99
confidence_level = c(0.9, 0.95, 0.99);

# SD confidence function
sd_confidence <- function(mean, n, confidence_level) {
  alpha = 1 - confidence_level;
  offset = qnorm(1 - alpha / 2) / sqrt(2*n);
  lower_bound = mean / (1 + offset);
  upper_bound = mean / (1 - offset);
  return(c(lower_bound, upper_bound));
};

# Calculate confidence
sd_confidence_intervals = sapply(confidence_level, function(conf_level) {
  sd_confidence(vii_price_mean, n, conf_level);
});

# Create matrix
sd_confidence_intervals = t(sd_confidence_intervals);
rownames(sd_confidence_intervals) = paste0("Poziom ufności: ", confidence_level);
colnames(sd_confidence_intervals) = c("Dolny przedział", "Górny przedział");

# Display
print("Przedziały ufności odchylenia standardowego dla różnych poziomów ufności:");
print(sd_confidence_intervals);
```

## Przedział ufności dla zmiennej jakościowej (frakcyjna)
Do wyznaczenia przedziału ufności dla zmiennej *PojazdUszkodzony* (rozkład Bernoulliego)
```{r, message = FALSE}
# Meta data 
# Confidence level 0.9, 0.95, 0.99
confidence_level = c(0.9, 0.95, 0.99);

# Basic data
vii_positive = sum(database$PojazdUszkodzony == TRUE);
vii_all      = length(database$PojazdUszkodzony);

mean_bool_confidence <- function(m, n, confidence_level) {
  alpha = 1 - confidence_level;
  mn = m / n;
  offset = qnorm(1 - alpha / 2) * sqrt(mn * (1-mn)) / sqrt(n);
  lower_bound = mn - offset;
  upper_bound = mn + offset;
  return(c(lower_bound, upper_bound));
};

# Calculate confidence
confidence_intervals = sapply(confidence_level, function(conf_level) {
  mean_bool_confidence(vii_positive, vii_all, conf_level);
});

# Create matrix
confidence_intervals = t(confidence_intervals);
rownames(confidence_intervals) = paste0("Poziom ufności: ", confidence_level);
colnames(confidence_intervals) = c("Dolny przedział", "Górny przedział");

# Display
print("Przedziały ufności dla frakcji dla różnych poziomów ufności (Udział pojazdów uszkodzonych):");
print(confidence_intervals);
```

# VII - Testowanie hipotez

## Zmienne jakościowe

### Test niezależności 
Do testu niezależności wykorzystano dane dotyczące kraju pochodzenia oraz marki.
Celem testu jest podtwierdzenie niezależności wyboru marki względem kraju.
H0 - zmienne są niezależne,
H1 - zmienne nie są niezależne.
```{r}
print(table(database$KrajPochodzenia, database$Marka));
vii_test = chisq.test(table(database$Marka, database$SkrzyniaBiegowManualna));
print(vii_test)
```
Test to potwierdza (p-value < 0.05) mamy podstawy do odrzucenia hipotezy zerowej na korzyść hipotezy alternatywnej - 
istnieje zależność krajem pochodzenia, a marką.


### Test proporcji
Test proprcji w którym wykorzystano liczbę samochodów uszkodzonych oraz kraj pochodzenie.
H0 - odsetek samochodów uszkodzonych jest niezależny od kraju pochodzenia.
```{r}
vii_proporcja = database %>% group_by(database$KrajPochodzenia) %>% summarise(liczba = n());
vii_proporcja$uszkodzonych = table(database$KrajPochodzenia, database$PojazdUszkodzony)[,2];
vii_proporcja = vii_proporcja %>% filter(liczba > 500);
vii_test = prop.test(x = vii_proporcja$uszkodzonych, n = vii_proporcja$liczba);
print(vii_test);
```
### Zmienne ilościowe
Testowanie normalności względem ceny, test pozwala na potwierdzenie tezy o normalności rozkładu.
H0 -  doświadczenie ma rozkład normalny.
```{r}
vii_test = ad.test(database$CenaPLN);
print(vii_test);
ggplot(database, aes(sample = CenaPLN)) +
  stat_qq() +
  stat_qq_line();
```
Cena nie jest zmienną o rozkładzie normalnym.

### Test Wilcoxona
Ze względu na to, iż cena nie jest zmienną o rozkładzie normalnym. Wykorzystujemy nieparametryczny test Wilcoxona.
H0 - średnia jest równa 34656.
```{r}
wilcox.test(x = database$CenaPLN, mu = 34656)
```

# IX - Regresja liniowa i inne

## Modele dla jednej zmiennej
```{r, message = FALSE}
ix_database = select(filter(database, PojazdUszkodzony==FALSE & SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "PrzebiegKm"))
model = lm(CenaPLN ~ . , data = ix_database)
ix_sample = ix_database[sample(nrow(ix_database), size=1000),]
plot(CenaPLN ~ PrzebiegKm,  data=ix_sample, col = 'darkcyan')
abline(model, col="red")

summary(model);
print(model$coefficients);
```
```{r, message = FALSE}
ix_database = select(filter(database, PojazdUszkodzony==FALSE & SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "PojemnoscSkokowa"))
model = lm(CenaPLN ~ . , data = ix_database)
ix_sample = ix_database[sample(nrow(ix_database), size=1000),]
plot(CenaPLN ~ PojemnoscSkokowa,  data=ix_sample, col = 'darkcyan')
abline(model, col="red")

summary(model);
print(model$coefficients);
```

## Modele dla 2 zmiennych
```{r, message = FALSE, rgl = TRUE}
ix_database = select(filter(database, PojazdUszkodzony==FALSE & SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "PrzebiegKm", "PojemnoscSkokowa"))
model = lm(CenaPLN ~ . , data = ix_database)

plot3d(model, col='darkcyan', plane.col = 'red')
rglwidget()

summary(model);
print(model$coefficients);
```

## Drzewa decyzyjne
```{r, message = FALSE}
ix_database = select(filter(database, PojazdUszkodzony==FALSE & SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "RokProdukcji", "PojemnoscSkokowa"))
ix_data_split = initial_split(ix_database, prop = 0.75);
ix_train_data <- training(ix_data_split);
ix_test_data <- testing(ix_data_split);

tree_spec <- decision_tree() %>%
 set_engine("rpart") %>%
 set_mode("regression")

tree_fit <- tree_spec %>%
 fit(CenaPLN ~ ., data = ix_train_data)

predictions <- tree_fit %>%
 predict(ix_test_data) %>%
 pull(.pred)

metrics <- metric_set(rmse, rsq)
model_performance <- ix_test_data %>%
 mutate(predictions = predictions) %>%
 metrics(truth = CenaPLN, estimate = predictions)

print(model_performance)

rpart.plot(tree_fit$fit, type = 5, extra = 101, under = TRUE, cex = 0.8, box.palette = "auto")
```