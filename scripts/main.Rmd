---
output:
  pdf_document: default
  html_document: default
  word_document: default
---
```{r, echo=FALSE, include=FALSE}
#install.packages("dplyr")
#install.packages("ggplot2")
#install.packages("viridis")
#install.packages("tidyverse")
#install.packages("hrbrthemes")
#install.packages("corrplot")
#install.packages("tidymodels")
#install.packages("rpart.plot")
#install.packages("rgl")
#install.packages("readxl")
#install.packages("nortest")
#install.packages("moments")
#install.packages("psych")
#install.packages("tinytex")
#install.packages("kableExtra")
#install.packages("webshot2")

library(dplyr)
library(ggplot2)
library(viridis)
library(tidyverse)
library(hrbrthemes)
library(corrplot)
library(tidymodels)
library(rpart.plot)
library(rgl)
library(readxl)
library(nortest)
library(patchwork)
library(moments)
library(psych)
library(tinytex)
library(kableExtra)
library(webshot2)
```

\vspace*{5cm}

\begin{center}
  \Huge \textbf{Statystyka matematyczna i ekonometria}

  \vspace{2cm}

  \LARGE Projekt - Auto Sprzedam

  \vspace{3cm}

  \Large \textbf{Autorzy} \\ 
  Anna Kalitka (255445) \\
  Antoni Bezdzietny (249327)

  \vspace{4cm}

  \Large Projekt zaliczeniowy \\
  Laboratorium, lato 2023/24
  
\vspace {4cm}

\end{center}  

# I - Opis bazy danych
  Wybrana została baza danych **AutoSprzedam**. Baza pochodzi z zasobów ePortalu.
  
  
## Zawartość bazy danych
  Baza danych składa się z 41034 rekordów, zawierających szczegółowe dane dotyczące sprzedaży samochodów m.in.

  <p style="text-align:center;">
  | Kolumna            | Typ danych | Opis                                                                                      |
  |--------------------|------------|-------------------------------------------------------------------------------------------|
  | NrOferty           | int        | Numer oferty sprzedaży samochodu.                                                         |
  | CenaPLN            | string     | Cena samochodu wyrażona w polskich złotych (PLN).                                         |
  | KM                 | int        | Liczba koni mechanicznych samochodu.                                                      |
  | Marka              | string     | Marka samochodu.                                                                          |
  | Model              | string     | Model samochodu.                                                                          |
  | LiczbaDrzwi        | string     | Liczba drzwi w samochodzie.                                                               |
  | PojemnoscSkokowa   | int        | Pojemność skokowa silnika wyrażona w centymetrach sześciennych (cm³).                     |
  | PrzebiegKm         | int        | Przebieg samochodu wyrażony w kilometrach.                                                |
  | RodzajPaliwa       | string     | Rodzaj paliwa używanego przez samochód (benzyna, diesel, hybryda, elektryczny itp.).      |
  | RokProdukcji       | int        | Rok produkcji samochodu.                                                                  |
  | Kolor              | string     | Kolor samochodu.                                                                          |
  | KrajPochodzenia    | string     | Kraj pochodzenia samochodu.                                                               |
  | PojazdUszkodzony   | string     | Informacja czy pojazd jest uszkodzony (Tak/Nie).                                          |
  | SkrzyniaBiegow     | string     | Typ skrzyni biegów w samochodzie (manualna, automatyczna).                                |
  </p>
 \newpage 
## Prezentacja bazy danych
```{r}
# Wczytanie bazy danych
database = read.csv("../database/AutoSprzedam.dat", sep = "\t", dec = ',');
cat("Liczba rekordów:", nrow(database), ", liczba kolumn:", ncol(database), "\n")
N = 5;
  cat("-", "Przykład ", N, "pierwszych rekordów.\n") 
head(database, N)
  cat("- ", "Przykład ", N, "ostatnich rekordów.\n") 
  tail(database, N)
```
\newpage
## Przygotowanie bazy danych
  Przed przejściem do dalszej pracy z bazą danych postanowiono wprowadzenie zmian w jej strukturze, 
  których celem jest uproszczenie przyszłych prac z danymi.

### Pole - *SkrzyniaBiegow*
  W bazie występują 3 rodzaje typów skrzyni biegów: *półautomatyczna/sekwencyjna*, *manualna* oraz *automatyczna*.
  Udział typu *półautomatyczna/sekwencyjna* w całej bazie wynosi 1,5%.
  
  W związku z niewielkim udziałem ze skrzynią *półautomatyczna/sekwencyjna*, typ ten został usunięty z bazy. 
  Dzięki czemu możliwe jest przekształcenie kolumny *SkrzyniaBiegow* (char), na *SkrzyniaBiegowManualna* (bool).
```{r}
gear_box_summary = database %>% group_by(database$SkrzyniaBiegow) %>% summarise(liczba = n());

gear_box_summary
cat("Udział pojazdów ze skrzynią biegów typu 'półautomatyczna/sekwencyjna'", 
    sum(gear_box_summary[3,2])/sum(gear_box_summary[,2])*100, "%.");

# Remove cars with database$SkrzyniaBiegow == 'półautomatyczna/sekwencyjna'
database = database[database$SkrzyniaBiegow != "półautomatyczna/sekwencyjna",];

# Cast to logical value
database$SkrzyniaBiegow = database$SkrzyniaBiegow == "manualna";
colnames(database)[14] = "SkrzyniaBiegowManualna";
```

### Pole *PojazdUszkodzony*
  Domyślnym typem danych dla pola *PojazdUszkodzony* jest (char). Zmienna jest typem logicznym (TAK/NIE). 
  W związku z powyższym kolumna *PojazdUszkodzony* została przekształcona to typu *bool*.
```{r}
database$PojazdUszkodzony = database$PojazdUszkodzony == "Tak";
```

### Pole *Liczba drzwi*
W bazie występują pojazdy tylko i wyłącznie z dwoma liczbami drzwi *2/3* oraz *4/5*.
W związku z powyższym można analogicznie przekształcić typ danych na typ *bool*.
```{r}
database$LiczbaDrzwi = database$LiczbaDrzwi == "4/5";
colnames(database)[6] = "LiczbaDrzwi4/5"
```
\newpage
## Prezentacja bazy danych - po wprowadzonych zmianach
```{r}
N = 5;
cat("-", "Przykład ", N, "pierwszych rekordów.\n")
head(database, N)

cat("- ", "Przykład ", N, "ostatnich rekordów.\n")
tail(database, N)
```
\newpage
# II - Wyznaczenie podstawowych statystyk
W tej sekcji przedstawione zostaną podstawowe statystyki dla wybranych zmiennych, które zostały użyte w tym projekcie.

\textbf {Miary położenia} :\
- Średnią arytmetyczną w próbce nazywamy miarę wyrażoną wzorem:
$$\overline{x} = \frac{1}{n} \sum_{i=1}^{n} x_i$$
- Średnia harmoniczna jest odwrotnością średniej arytmetycznej, gdzie dla szeregu szczegółowego obliczamy ze wzoru: 
$$\frac{n}{\sum_{i=1}^{n} \frac{1}{x_i}}$$
- Średnia geometryczna pozwala na ocenę przeciętnej cechy mierzalnej w zbiorowości statystycznej i przedstawia się wzorem:
$$\sqrt[n]{x_1 \cdot x_2 \cdot \ldots \cdot x_n}$$
- Mediana jest to środkowa wartość danych, przedstawimy ja za pomocą wzoru:
a) dla n nieparzystych
$$\text{Mediana} = x_{\left(\frac{n+1}{2}\right)}$$
b) dla n parzystych
$$\text{Mediana} = \frac{x_{\left(\frac{n}{2}\right)} + x_{\left(\frac{n}{2} + 1\right)}}{2}$$
- Kwartyle służą do wyznaczania wartości, wokół której grupują się dane, przykładowo wyróżniamy następujące kwartyle:
  + pierwszy kwartyl Q1 - mediana grupy obserwacji mniejszych od Q2,
  + drugi kwartyl Q2 to mediana,
  + trzeci kwartyl Q3 - mediana grupy obserwacji większych od Q2
 

\textbf {Miary rozproszenia} :\
- Rozstęp międzykwartylowy jest to różnica między trzecim a pierwszym kwartylem:
$$IQR=Q_3-Q_1$$
- Rozstęp jest różnicą między wartością maksymalną a minimalną:
$$R=x_{(n)}-x_{(1)}$$
- Wariancję przedstawiamy wzorem:
$$S^2=\frac{1}{n-1}\sum\limits_{i=1}^n(x_i-\overline{x})^2$$
- Odchylenie standardowe jest to pierwiastek z wariancji:
$$S=\sqrt{S^2}$$
- Odchylenie przeciętne od wartości średniej obliczamy ze wzoru:
$$d=\frac{1}{n}\sum\limits_{i=1}^n|x_i-\overline{x}|$$
- Współczynnik zmienności jest to parametr określający miarę zróżnicowania próby:
$$V=\frac{S}{\overline{x}}$$
\newpage

## Statystyki dla zmiennych nuemrycznych

```{r}
numerical_database = data.frame(database$CenaPLN, database$KM, 
                                database$PojemnoscSkokowa, database$PrzebiegKm, 
                                database$RokProdukcji);
numerical_statistics = data.frame(do.call(cbind, lapply(numerical_database, summary)));
numerical_statistics[nrow(numerical_statistics)+1,] = 
  sapply(numerical_database, var);
numerical_statistics[nrow(numerical_statistics)+1,] = 
  sapply(numerical_database, sd);
numerical_statistics[nrow(numerical_statistics) + 1, ] = 
  sapply(numerical_database, function(x) sd(x) / mean(x))
numerical_statistics[nrow(numerical_statistics) + 1, ] = 
  sapply(numerical_database, skewness)
numerical_statistics[nrow(numerical_statistics) + 1, ] = 
  sapply(numerical_database, kurtosis)
numerical_statistics[nrow(numerical_statistics) + 1, ] = 
  sapply(numerical_database, harmonic.mean)
numerical_statistics[nrow(numerical_statistics) + 1, ] = 
  sapply(numerical_database, geometric.mean)
row.names(numerical_statistics)[7:13] <- c("Var", "Sd", "CV", "Skewness", "Kurtosis", 
                                           "HarmonicMean", "GeometricMean")
colnames(numerical_statistics) <- c("CenaPLN", "KM", "PojemnoscSkokowa", "PrzebiegKm", "RokProdukcji")
numerical_statistics[,-ncol(numerical_statistics)] <- 
  lapply(numerical_statistics[,-ncol(numerical_statistics)], function(x) 
  format(x, scientific = TRUE, digits = 2))
#numerical_statistics
numerical_statistics %>%
kable("latex") %>%
kable_styling(full_width = FALSE, 
             bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
                position = "center") %>%
  add_header_above(c("Miary","Statystyki"=5)) %>%
  row_spec(0, bold = TRUE, background = "#006400", color = "white") %>%
 column_spec(1:5, border_right = TRUE)

```
# Interpretacja danych dla CenaPLN

\textbf {Centrum rozkładu:}\
Dane są niejednorodne i wyraźnie prawostronnie skośne, co potwierdza wysoka wartość mediany (26000), która lepiej odzwierciedla przeciętną wartość w porównaniu do średniej arytmetycznej (40848). Średnia jest silnie wpływana przez skrajne wartości, co sprawia, że jest zdecydowanie większa od mediany. Wartość średniej harmonicznego oraz średniej geometrycznej leży pomiędzy medianą a średnią arytmetyczną.
```{r}
t(numerical_statistics)[1,c(1:6,12,13)]

```
\textbf {Miary rozproszenia:}\
Rozstęp między wartościami minimalną i maksymalną jest bardzo duży (60266.69), co wskazuje na znaczną zmienność danych.
Rozstęp międzykwartylowy (IQR) jest stosunkowo niski (4386.29), co sugeruje, że większość danych skupia się wokół mediany.
Wysokie wartości odchylenia standardowego (51347.64) oraz odchylenia przeciętnego świadczą o dużym rozrzuceniu danych wokół średniej                  arytmetycznej.

```{r}
t(numerical_statistics)[1,c(7,8,9)]

```
\textbf {Kształt rozkładu:}\
Współczynnik zmienności (CV) wynoszący ponad 100% wskazuje na dużą zmienność danych.
Skośność (Skewness) jest dodatnia (6.03), co potwierdza prawostronną skośność rozkładu.
Kurtosis wynoszący 93.59 wskazuje na występowanie wartości skrajnych i grubszych "ogonów" rozkładu, co oznacza, że rozkład jest bardziej              spiętrzony wokół środka niż rozkład normalny.

```{r}
t(numerical_statistics)[1,c(10,11)]
``` 
\textbf {Wniosek ogólny:}\
Dane wykazują dużą zmienność, zdecydowaną prawostronną skośność oraz obecność wartości skrajnych. To sugeruje, że analizowane zjawisko nie jest równomiernie rozłożone i może być podatne na występowanie ekstremalnych wartości. Użycie średniej arytmetycznej jako miary centralnej może być mniej odpowiednie, gdyż jest silnie wpływana przez wartości skrajne. Mediana lepiej odzwierciedla przeciętną wartość w takich warunkach. Duża wartość współczynnika zmienności i kurtozy potwierdza istnienie dużej zmienności i obecność wartości skrajnych w badanych danych.
\newpage

## Statystyki dla zmiennych dwumianowych

```{r}
logical_database = data.frame(database$`LiczbaDrzwi4/5`, 
                              database$PojazdUszkodzony, 
                              database$SkrzyniaBiegowManualna);

logical_statistics = data.frame(do.call(cbind, lapply(logical_database, summary)))[2:3,];
logical_statistics = data.frame(Class = c("False", "True"),
                                PojazdUszkodzony = as.double(logical_statistics$database.PojazdUszkodzony),
                                SkrzyniaBiegowManualna = as.double(logical_statistics$database.SkrzyniaBiegowManualna),
                                LiczbaDrzwi4_5 = as.double(logical_statistics$database..LiczbaDrzwi4.5.))
logical_statistics
```
\textbf {Wniosek:}\ 
Zdecydowana większość pojazdów w próbie jest nieuszkodzona.
W kategorii pojazdów z manualną skrzynią biegów i z 4-5 drzwiami, uszkodzone pojazdy stanowią znaczną większość.
Pojazdy z manualną skrzynią biegów i z większą liczbą drzwi mogą być bardziej narażone na uszkodzenia lub też w tych kategoriach pojazdy uszkodzone stanowią większą część próby.

## Statystyki dla pozostałych zmiennych (jakościowych)

```{r}
quality_database = data.frame(database$Marka, 
                              database$RodzajPaliwa, 
                              database$Kolor, 
                              database$KrajPochodzenia);

sapply(quality_database, function (x){
  round(sort(table(x), decreasing = TRUE) / nrow(quality_database) , 3)})

```
```{r}
``` 
\textbf {Wnioski do Marek:}\
        Najpopularniejszą marką jest Volkswagen, stanowiący 15.1% pojazdów.
        Ford i Opel są kolejnymi popularnymi markami, z udziałami odpowiednio 13.2% i 12.2%.
        Widać dużą różnorodność marek, z dziesięcioma najpopularniejszymi markami obejmującymi większość rynku.
        
\textbf {Wnioski napęd:}\
        Olej napędowy (diesel) jest dominującym rodzajem paliwa, stanowiącym 68% pojazdów.
        Paliwa alternatywne, takie jak hybrydy, benzyna+CNG i napęd elektryczny, stanowią bardzo mały procent (mniej niż 1%).
        
\textbf {Wnioski Kolor:}\
        Najczęściej wybieranym kolorem jest srebrny-metallic (25.2%), a następnie czarny-metallic (19.1%).
        Kolory metaliczne, zwłaszcza srebrny i czarny, są bardzo popularne, co może sugerować preferencje klientów do bardziej eleganckiego wyglądu.
        
\textbf {Wnioski kraj pochodzenia:}\
        Niemcy są dominującym krajem pochodzenia pojazdów, z 39.8% udziałem.
        Polska zajmuje drugie miejsce z 29.8% udziałem, co może wskazywać na dużą liczbę pojazdów produkowanych lub importowanych z Polski.        

\textbf {Ogólne wnioski:}\
        Dane wskazują na preferencje rynku dotyczące określonych marek (głównie niemieckich), typów paliwa (przede wszystkim diesel) oraz kolorów (metalicznych).
        Niemieckie marki i pojazdy pochodzenia niemieckiego są najbardziej popularne.
        Bardzo mały udział pojazdów hybrydowych, na CNG oraz elektrycznych wskazuje na niewielkie zainteresowanie tymi bardziej ekologicznymi opcjami.
\newpage

# III - Graficzna prezentacja danych
```{r, include=FALSE}
# Functions used for display

# Remove outlier sample
interquartile_range = function(x, iqr_factor = 1.5){
  Q1 = quantile(x, 0.25);
  Q3 = quantile(x, 0.75);
  IQR = Q3-Q1;
  lower_bound = Q1 - iqr_factor*IQR;
  upper_bound = Q3 + iqr_factor*IQR; 
  return(x[which(x >= lower_bound & x <=upper_bound)]);
}

# Draw histogram
draw_histogram = function(x){
  h1 = ggplot() + 
    geom_histogram(aes(x=x, y = after_stat(density)), 
                 colour = 'red3', fill = 'red2', bins = 50) +
    geom_density(aes(x=x), lwd = 1, colour = 4,
               fill = 4, alpha = 0.25) + labs(x = "Wartość", y = "Gęstość") +
    ggtitle("Histogram oraz gęstość /n wszystkie dane");

  h2 = ggplot() + 
    geom_histogram(aes(x=interquartile_range(x), y = after_stat(density)), 
                 colour = 'red3', fill = 'red2', bins = 50) +
    geom_density(aes(x=interquartile_range(x)), lwd = 1, colour = 4,
               fill = 4, alpha = 0.25) + labs(x = "Wartość", y = "Gęstość") +
    ggtitle("Histogram oraz gęstość /n odrzucone skrajne");
  
  return(h1/h2)
}

# Draw boxplot
draw_boxplot = function(x, y_lab = "Wartość"){
  h3 = ggplot() + geom_boxplot(aes(y=database$CenaPLN), colour = "black") +
    scale_fill_viridis(discrete = TRUE, alpha=0.6) +
    labs(y = y_lab) + ggtitle("Pudełko-wąsy wszystkie dane")

  h4 = ggplot() + geom_boxplot(aes(y=interquartile_range(database$CenaPLN)), colour = "black") +
    scale_fill_viridis(discrete = TRUE, alpha=0.6) + 
    labs(y = y_lab) + ggtitle("Pudełko-wąsy odrzucone skrajne")
  
  return(h3/h4)
}

draw_numerical = function(x, y_lab="Wartość"){
    draw_histogram(x) |
  draw_boxplot(x, y_lab) + plot_layout(ncol = 2);
}

```

## Wykresy dla zmiennych nuemrycznych
```{r}
sapply(numerical_database, draw_numerical);
```

\newpage
## Statystyki dla zmiennych jakościowych/ Wykresy kołowy - uszkodzenia, typ skrzyni, liczba drzwi

Wnioski do wykresów zostały zawarte w częciści "Statystyki dla zmiennych dwumianowych"

```{r}
ggplot(logical_statistics, aes(x="", y=PojazdUszkodzony, fill=Class)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() +
  geom_text(aes(label=PojazdUszkodzony), position=position_stack(vjust=0.5)) +
  ggtitle("Pojazd uszkodzony")

ggplot(logical_statistics, aes(x="", y=SkrzyniaBiegowManualna, fill=Class)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() +
  geom_text(aes(label=SkrzyniaBiegowManualna), position=position_stack(vjust=0.5)) +
  ggtitle("Skrzynia manualna")

ggplot(logical_statistics, aes(x="", y=LiczbaDrzwi4_5, fill=Class)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() +
  geom_text(aes(label=LiczbaDrzwi4_5), position=position_stack(vjust=0.5)) +
  ggtitle("Liczba drzwi 4/5")
```
\newpage

# Wykresy słupkowe

```{r, message = FALSE}
wzg_marka = database %>% group_by(Marka) %>% summarise(liczbaSprzedanych = n(), 
                                                    sredniaCena = mean(CenaPLN),
                                                    medianaCena = median(CenaPLN));

ggplot(wzg_marka, aes(y=Marka, x=sredniaCena)) + 
    geom_bar(position="dodge", stat="identity", fill="orange")+
    ggtitle("Średnia cena sprzedaży dla marki")

ggplot(wzg_marka, aes(y=Marka, x=liczbaSprzedanych)) + 
    geom_bar(position="dodge", stat="identity", fill="lightblue")+
    ggtitle("Liczba sprzedanych pojazdów")

wzg_marka
```
\textbf {Ogólne wnioski:}\
Marki takie jak Ford, Renault, Opel oraz Peugeot mają znaczną liczbę sprzedanych pojazdów (powyżej 3000), co może sugerować ich dużą popularność na rynku.

Marki takie jak Audi, BMW, Mercedes-Benz oraz Toyota wyróżniają się wysokimi średnimi i medianami cen, co sugeruje, że oferują one pojazdy z wyższej półki cenowej. Dla przykładu, Audi i BMW mają średnie ceny sprzedaży przekraczające 85 000 zł, podczas gdy mediana cen wynosi odpowiednio 52 800 zł i 56 900 zł.

Fiat wyróżnia się najniższą średnią i medianą ceną sprzedaży spośród wszystkich marek, co może wskazywać na ofertę pojazdów bardziej przystępnych cenowo.

Skoda i Toyota mają relatywnie wysokie średnie i mediany cen, co może sugerować, że oferują one pojazdy w średniej do wysokiej półce cenowej, podobnie jak Audi, BMW i Mercedes-Benz.

Różnice w liczbie sprzedanych pojazdów oraz cenach wskazują na zróżnicowane preferencje konsumentów na rynku samochodowym. Niektóre marki mogą być bardziej cenione ze względu na swoje cechy, reputację czy oferowane technologie.

## Statystyki dla zmiennych jakościowych/ Wykresy kołowy - napęd

Wnioski do wykresów zostały zawarte w częciści "Statystyki dla zmiennych dwumianowych"

```{r, message = FALSE}
fuelType = database %>% group_by(database$RodzajPaliwa) %>% summarise(liczba = n());
colnames(fuelType) = c("FuelType", "Count");
fuelType = fuelType[order(fuelType$Count, decreasing = TRUE),]
fuelType

ggplot(fuelType, aes(x="", y=Count, fill=FuelType)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) + theme_void();
```


# IV - Obserwacje odstające
Obserwacja odstająca, element odstający – obserwacja relatywnie odległa od pozostałych elementów próby. 
Innymi słowy, posiadająca nietypową wartość zmiennej niezależnej (objaśniającej) lub nietypowe wartości obydwu zmiennych – 
zależnej (objaśnianej) i objaśniającej (objaśniających w analizie regresji wielokrotnej). 

## Redukcja danych odstających zgodnie z regułą 3 sigma (*CenaPLN*)
Redukcja danych zgodnie z regułą 3 sigma. 

Identyfikacja danych odstających za pomocą reguły trzech sigm:

1. Obliczenie średniej ($\mu$): Najpierw oblicza się średnią dla danego zbioru danych.

2. Obliczenie odchylenia standardowego ($\sigma$): Następnie oblicza się odchylenie standardowe, które mierzy, jak bardzo dane rozpraszają się wokół średniej.

3. Ustalenie zakresu trzech sigm: Wartości, które znajdują się poza zakresem trzech sigm ($\mu$ ± 3$\sigma$), są uznawane za dane odstające.

```{r}
iv_sigma_mean_price = mean(database$CenaPLN);
iv_sigma_sd_price   = sd(database$CenaPLN);

iv_sigma_lower_bound <- iv_sigma_mean_price - 3 * iv_sigma_sd_price;
iv_sigma_upper_bound <- iv_sigma_mean_price + 3 * iv_sigma_sd_price;

cat("Wyznacznowe granice metodą 3 sigma: \n")
cat("Dolna granica ", iv_sigma_lower_bound, ", górna granica ", iv_sigma_upper_bound, "\n");

iv_n_sigma_outlier = sum(database$CenaPLN >= iv_sigma_upper_bound |
                         database$CenaPLN <= iv_sigma_lower_bound)

cat("Ilość elementów odstających zgodnie z regułą 3 sigma dla CenaPLN n =", iv_n_sigma_outlier, "\n");
```

## Redukcja danych odstających regułą odstępu międzykwartylowgo (*PrzebiegKM*)
Metoda redukcji, polega na wykrywaniu i usuwaniu wartości odstających z zestawu danych. Metoda ta opiera się na kwartylach i rozstępie międzykwartylowym.

1. Wyznaczenie *Q1* (pierwszy kwartyl) oraz *Q3* (trzeci kwartyl)

2. Wyznaczenie odstępu międzykwartylowego *IQR = Q3 - Q1*

3. Wyznaczenie dolnej *Q1 - 1.5 x IQR* oraz górnej *Q1 + 1.5 x IQR* granicy.

```{r}
iv_Q1 = quantile(database$PrzebiegKm, 0.25);
iv_Q3 = quantile(database$PrzebiegKm, 0.75);
iv_IQR = iv_Q3-iv_Q1;
iv_lower_bound = iv_Q1 - 1.5*iv_IQR #mniejsze niż
iv_upper_bound = iv_Q3 + 1.5*iv_IQR #większe niż 

cat("Wyznacznowe granice metodą odstępu międzykwartylowgo  \n")
cat("Dolna granica ", iv_lower_bound, ", górna granica ", iv_upper_bound, "\n");

iv_n_outlier = sum(database$PrzebiegKm >= iv_upper_bound |
                   database$PrzebiegKm <= iv_lower_bound)

cat("Ilość elementów odstających zgodnie z regułą odstępu międzykwartylowego PrzebiegKm n =", iv_n_outlier, "\n");
```

# V - Wyznaczanie prawdopodobieństw dla zmiennej

## Rozkłady dyskretne

### Dwumianowy
```{r}
set.seed(42);
N = 1e4; # Liczba próbek
n <- 20;
p <- 0.4;

# Prawdopodobieństwo punktowe
print(paste("Prawdopodobieństwo dla punktu P(x=8)=", dbinom(8, n, p)));

# Prawdopodobieństwo przedzizłowe
print(paste("Prawdopodobieństwo dla punktu P(x<10)=", pbinom(10, n,p)));

# Wygenerowanie rozkładu gęstości
x = seq(0, n, 1);
dx = dbinom(x, n, p);

# Wyznaczenie przedziału 
n1<-seq(from=0, to=10, by=1)
k1<-data.frame(x=n1, y=dbinom(n1, n, p))
k1<-rbind(c(min(n1), 0), k1, c(max(n1), 0))

# Wykres gęstości
ggplot(data.frame(x=x, y=dx))+geom_point(aes(x=x, y=y))+labs(x="x",y="d(x)") +
  ggtitle("Gęstość")+geom_point(data=k1, aes(x=x, y=y), col="yellow", fill="yellow", alpha=0.2);

# Wykres dystrybuanty
ggplot(data.frame(x=x, y=pbinom(q=x, n, p)))+geom_point(aes(x=x, y=y))+
  labs(x="q",y="p(q)") + ggtitle("Dystrybuanta");
```


### Rozkład Poissona
```{r}
N = 1e4; # Liczba próbek
lmb = 200; # Lambda

# Prawdopodobieństwo punktowe
print(paste("Prawdopodobieństwo dla punktu P(x=180)=", dpois(180, lambda = lmb)));

# Prawdopodobieństwo przedzizłowe
print(paste("Prawdopodobieństwo dla punktu P(180<x<220)=", ppois(220, lmb)-ppois(180, lmb)));

# Wygenerowanie rozkładu gęstości
x = seq(0, 2*lmb, 1);
dx = dpois(x, lmb);

# Wyznaczenie przedziału 
n1<-seq(from=180, to=220, by=1)
k1<-data.frame(x=n1, y=dpois(n1, lmb))
k1<-rbind(c(min(n1), 0), k1, c(max(n1), 0))

# Wykres gęstości
ggplot(data.frame(x=x, y=dx))+geom_point(aes(x=x, y=y))+labs(x="x",y="d(x)") +
  ggtitle("Gęstość")+geom_polygon(data=k1, aes(x=x, y=y), col="yellow", fill="yellow", alpha=0.2);

# Wykres dystrybuanty
ggplot(data.frame(x=x, y=ppois(q=x, lmb)))+geom_line(aes(x=x, y=y))+
  labs(x="q",y="p(q)") + ggtitle("Dystrybuanta");
```

## Rozkłady ciągłe 

### Rozkład normalny
```{r}
N = 1e4; # Liczba próbek
mu = 10; # Srednia
sd = 5 ; # Odchylenie 

# Prawdopodobieństwo punktowe
print(paste("Prawdopodobieństwo dla punktu P(x=8)=", dnorm(8, mean = mu, sd = sd)));

# Prawdopodobieństwo przedzizłowe
print(paste("Prawdopodobieństwo dla punktu P(8<x<10)=", pnorm(10, mean = mu, sd = sd)-pnorm(8, mean = mu, sd = sd)));

# Wygenerowanie rozkładu gęstości
x = seq(mu-5*sd, mu+5*sd, length.out=1e4);
dx = dnorm(x = x, mean = mu, sd = sd);

# Wyznaczenie przedziału 
n1<-seq(from=8, to=10, by=0.01)
k1<-data.frame(x=n1, y=dnorm(n1, mean = mu, sd = sd))
k1<-rbind(c(min(n1), 0), k1, c(max(n1), 0))

# Wykres gęstości
ggplot(data.frame(x=x, y=dx))+geom_line(aes(x=x, y=y))+labs(x="x",y="d(x)") +
  ggtitle("Gęstość")+geom_polygon(data=k1, aes(x=x, y=y), col="yellow", fill="yellow", alpha=0.2);

# Wykres dystrybuanty
ggplot(data.frame(x=x, y=pnorm(q=x, mean = mu, sd = sd)))+geom_line(aes(x=x, y=y))+
  labs(x="q",y="p(q)") + ggtitle("Dystrybuanta");
```
### Rozkład beta
```{r}
N = 1e4; # Liczba próbek
a = 2; # Alpha
b = 5; # Beta 

# Prawdopodobieństwo punktowe
print(paste("Prawdopodobieństwo dla punktu P(x=0.8)=", dbeta(0.8, a, b)));

# Prawdopodobieństwo przedzizłowe
print(paste("Prawdopodobieństwo dla punktu P(0.6<x<1.0)=", pbeta(1., a, b)-pbeta(0.6, a, b)));

# Wygenerowanie rozkładu gęstości
x = seq(0, 1, length.out=1e4);
dx = dbeta(x, a, b);

# Wyznaczenie przedziału 
n1<-seq(from=0.6, to=1.0, by=0.01)
k1<-data.frame(x=n1, y=dbeta(n1, a, b))
k1<-rbind(c(min(n1), 0), k1, c(max(n1), 0))

# Wykres gęstości
ggplot(data.frame(x=x, y=dx))+geom_line(aes(x=x, y=y))+labs(x="x",y="d(x)") +
  ggtitle("Gęstość")+geom_polygon(data=k1, aes(x=x, y=y), col="yellow", fill="yellow", alpha=0.2);

# Wykres dystrybuanty
ggplot(data.frame(x=x, y=pbeta(x, a, b)))+geom_line(aes(x=x, y=y))+
  labs(x="q",y="p(q)") + ggtitle("Dystrybuanta");
```


# VI - Budowa macierzy z bazy danych
Do zbudowanie macierzy wykorzystano wszystkie dostępne numeryczne dane tj. *CenaPLN*, *KM*, *PrzebiegKm*, *RokProdukcji*, *PojemnoscSkokowa*. 
Dzięki temu możliwe jest wyznaczenie macierzy korelacji pomiędzy danymi.
```{r, message = FALSE}
# Select data
vi_database = data.matrix(select(filter(database, PojazdUszkodzony==FALSE & SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "KM", "PrzebiegKm", "RokProdukcji", "PojemnoscSkokowa")))

#Is matrix
is.matrix(vi_database)

#Display head
head(vi_database) 

# Dimension
vi_dim <- dim(vi_database);
cat("Rozmiar macierzy:", vi_dim[1], "x", vi_dim[2]);

# Columns mean
vi_means = round(colMeans(vi_database), 3);
cat(paste(names(vi_means), vi_means, sep = " : ", collapse = ",\n"))

# Correlation 
vi_corr_matrix = cor(vi_database);
print(vi_corr_matrix)
corrplot(vi_corr_matrix, order = "hclust", 
         tl.col = "black", tl.srt = 45)
```
Jak można zaobserwować:
- *CenaPLN* skorelowana jest z *RokProdukcji* (silnie), *KM*, *PojemnoscSkokowa* oraz odwrotnie z *PrzebiegKM*,  
- *PojemnoscSkokowa* jest silnie skorelowana z ilością *KM* (większa pojemność -> więcej KM),
- *PrzebiegKM* jest odwrotnie skorelowany z *RokProdukcji* (starszy samochód -> większy przebieg).

# VII - Przedziały ufności
W tej sekcji przedstawione zostaną badania określające przedziały ufności z różnym stopniem 'zaufania'.
Oznacza to, że jeśli grupa badana była zgromadzona w sposób losowy to rzeczywisty parametr
populacji z z określonym stopniem 'zaufania' znajduje się w tym przedziale.

## Zmienna numeryczna
W celu określnenia przedziałów ufności zmiennej numerycznej wybrano cechę *CenaPLN*.

### Przedział ufności dla średniej:

Ze względu na dużą liczebność próby $n>30$, przedział ufności dla średniej zgodnie z wzorem:

$P\biggl( \overline{X} - u_{1- \frac{\alpha}{2}} \frac{s}{\sqrt{n}} , \overline{X} + u_{1-\frac{\alpha}{2}} \frac{s}{\sqrt{n}} \biggr)=1-\alpha$

gdzie: 

- $\overline{X}$ - średnia,

- $n$ - to liczebność próby losowej, 

- $s$ - to odchylenie standardowe z próby,

- $u_{\alpha}$ - to wartość kwantyla $1-\frac{\alpha}{2}$ rozkładu normalnego standaryzowanego dla poziomu istotności $\alpha$ . 
```{r, message = FALSE}
# Meta data 
# Confidence level 0.9, 0.95, 0.99
confidence_level = c(0.9, 0.95, 0.99);

# Basic data
vii_price_mean = mean(database$CenaPLN);
vii_price_sd = sd(database$CenaPLN);
n = length(database$CenaPLN);

# Mean confidence function
mean_confidence <- function(mean, sd, n, confidence_level) {
  alpha = 1 - confidence_level;
  offset = qnorm(1 - alpha / 2) * sd / sqrt(n);
  lower_bound = mean - offset;
  upper_bound = mean + offset;
  return(c(lower_bound, upper_bound));
};

# Calculate confidence
mean_confidence_intervals = sapply(confidence_level, function(conf_level) {
  mean_confidence(vii_price_mean, vii_price_sd, n, conf_level)
});

# Create matrix
mean_confidence_intervals = t(mean_confidence_intervals);
rownames(mean_confidence_intervals) = paste0("Poziom ufności: ", confidence_level);
colnames(mean_confidence_intervals) = c("Dolny przedział", "Górny przedział");

# Display
print("Przedziały ufności średniej dla różnych poziomów ufności:");
print(mean_confidence_intervals);
print(paste("Wartość średnia z próby:", round(vii_price_mean,2)));
```

### Przedział ufności dla odchylenia standardowego:

Ze względu na dużą liczebność próby $n>30$, przedział ufności dla odchylenia standardowego zgodnie z wzorem: 

$P\biggl(\frac{S}{1+\frac{u_{\alpha}}{\sqrt{2n}}}<\sigma<\frac{S}{1-\frac{u_{\alpha}}{\sqrt{2n}}}\biggr)=1-\alpha$

gdzie: 

- $n$ - to liczebność próby losowej, 

- $S$ - to odchylenie standardowe z próby,

- $u_{\alpha}$ - to wartość kwantyla $1-\frac{\alpha}{2}$ rozkładu normalnego standaryzowanego dla poziomu istotności $\alpha$ . 

```{r, message = FALSE}
# Meta data 
# Confidence level 0.9, 0.95, 0.99
confidence_level = c(0.9, 0.95, 0.99);

# Basic data
vii_price_mean = mean(database$CenaPLN);
vii_price_sd = sd(database$CenaPLN);
n = length(database$CenaPLN);

# SD confidence function
sd_confidence <- function(sd, n, confidence_level) {
  alpha = 1 - confidence_level;
  ua = qnorm(1 - alpha / 2);
  offset = ua  / sqrt(2*n);
  lower_bound = sd / (1 + offset);
  upper_bound = sd / (1 - offset);
  return(c(lower_bound, upper_bound));
};

# Calculate confidence
sd_confidence_intervals = sapply(confidence_level, function(conf_level) {
  sd_confidence(vii_price_sd, n, conf_level);
});

# Create matrix
sd_confidence_intervals = t(sd_confidence_intervals);
rownames(sd_confidence_intervals) = paste0("Poziom ufności: ", confidence_level);
colnames(sd_confidence_intervals) = c("Dolny przedział", "Górny przedział");

# Display
print("Przedziały ufności odchylenia standardowego dla różnych poziomów ufności:");
print(sd_confidence_intervals);
print(paste("Wartość odchylenia standardowego z próby:", round(vii_price_sd,2)));
```

## Przedział ufności dla zmiennej jakościowej (frakcyjna)
Do wyznaczenia przedziału ufności dla zmiennej *PojazdUszkodzony*.

$p \in (\frac{m}{n} – u_{1-\frac{\alpha}{2}} \frac{\sqrt{\frac{m}{n}\cdot(1-\frac{m}{n})}}{\sqrt{n}},\frac{m}{n} + u_{1-\frac{\alpha}{2}} \frac{\sqrt{\frac{m}{n}\cdot(1-\frac{m}{n})}}{\sqrt{n}} )$

gdzie:

$m$ - ilość zdarzeń sprzyjających,

$n$ - ilość wszystkich zdarzeń,

- $u_{\alpha}$ - to wartość kwantyla $1-\frac{\alpha}{2}$ rozkładu normalnego standaryzowanego dla poziomu istotności $\alpha$ .

```{r, message = FALSE}
# Meta data 
# Confidence level 0.9, 0.95, 0.99
confidence_level = c(0.9, 0.95, 0.99);

# Basic data
vii_positive = sum(database$PojazdUszkodzony == TRUE);
vii_all      = length(database$PojazdUszkodzony);

mean_bool_confidence <- function(m, n, confidence_level) {
  alpha = 1 - confidence_level;
  mn = m / n;
  offset = qnorm(1 - alpha / 2) * sqrt(mn * (1-mn)) / sqrt(n);
  lower_bound = mn - offset;
  upper_bound = mn + offset;
  return(c(lower_bound, upper_bound));
};

# Calculate confidence
confidence_intervals = sapply(confidence_level, function(conf_level) {
  mean_bool_confidence(vii_positive, vii_all, conf_level);
});

# Create matrix
confidence_intervals = t(confidence_intervals);
rownames(confidence_intervals) = paste0("Poziom ufności: ", confidence_level);
colnames(confidence_intervals) = c("Dolny przedział", "Górny przedział");

# Display
print("Przedziały ufności dla frakcji dla różnych poziomów ufności (Udział pojazdów uszkodzonych):");
print(confidence_intervals);
print(paste("Udział pojazdów uszkodzonych w zbiorze ", round(vii_positive/length(database$PojazdUszkodzony),2)))
```

## Przedział ufności dla zmiennej jakościowej
Do analizy wybrano pole *Marka*.

```{r}
vii_marka = database %>% group_by(database$Marka) %>% summarise(percent = n()/length(database$Marka));
```

### Przedział ufności dla średniaj z udziału *Marki* w zbiorze

Ze względu na mała liczebność próby $n<30$, przedział ufności dla odchylenia standardowego zgodnie z wzorem: 

$P( \overline{X} - t_{\alpha,n-1} \frac{s}{\sqrt{n}} , \overline{X} + t_{\alpha,n-1} \frac{s}{\sqrt{n}} ) = 1 - \alpha$

gdzie: 

- $\overline{X}$ - średnia,

- $n$ - to liczebność próby losowej, 

- $s$ - to odchylenie standardowe z próby,

- $t_{\alpha,n-1}$ -  dystrybuanta rozkładu t-studenta dla 1-a i n-1 stopni swobody. 
```{r}
# Meta data 
# Confidence level 0.9, 0.95, 0.99
confidence_level = c(0.9, 0.95, 0.99);

# Basic data
vii_marka_mean = mean(vii_marka$percent);
vii_marka_sd = sd(vii_marka$percent);
n = length(vii_marka$percent);

# Mean confidence function
mean_confidence <- function(mean, sd, n, confidence_level) {
  alpha = 1 - confidence_level;
  offset = pt(alpha, n-1) * sd / sqrt(n);
  lower_bound = mean - offset;
  upper_bound = mean + offset;
  return(c(lower_bound, upper_bound));
};

# Calculate confidence
mean_confidence_intervals = sapply(confidence_level, function(conf_level) {
  mean_confidence(vii_marka_mean, vii_marka_sd, n, conf_level)
});

# Create matrix
mean_confidence_intervals = t(mean_confidence_intervals);
rownames(mean_confidence_intervals) = paste0("Poziom ufności: ", confidence_level);
colnames(mean_confidence_intervals) = c("Dolny przedział", "Górny przedział");

# Display
print("Przedziały ufności średniej z danych jakościowych dla różnych poziomów ufności:");
print(mean_confidence_intervals);
print(paste("Wartość średnia z próby:", round(vii_marka_mean, 3)));
```

### Przedział ufności dla średniaj z udziału *Marki* w zbiorze

Ze względu na mała liczebność próby $n<30$, przedział ufności dla odchylenia standardowego zgodnie z wzorem: 

$P\biggl(\frac{n\cdot S^{2}}{\chi_{1-\frac{\alpha}{2},n-1}^{2}}<\sigma^{2}<\frac{n\cdot S^{2}}{\chi_{\frac{\alpha}{2},n-1}^{2}}\biggr)=1-\alpha$

gdzie: 

- $n$ - to liczebność próby losowej, 

- $S$ - to odchylenie standardowe z próby,

- $\chi_{1-\frac{\alpha}{2}, n-1}$ -  kwantyle rozkładu Chi-kwadrat 1-a i n-1 stopni swobody. 
```{r}
# Meta data 
# Confidence level 0.9, 0.95, 0.99
confidence_level = c(0.9, 0.95, 0.99);

# Basic data
vii_marka_mean = mean(vii_marka$percent);
vii_marka_sd = sd(vii_marka$percent);
n = length(vii_marka$percent);

# Mean confidence function
sd_confidence <- function(sd, n, confidence_level) {
  alpha = 1 - confidence_level;
  lower_bound = sqrt((n * sd * sd) / (qchisq(1-alpha/2, n-1)));
  upper_bound = sqrt((n * sd * sd) / (qchisq(alpha/2, n-1)));
  return(c(lower_bound, upper_bound));
};

# Calculate confidence
sd_confidence_intervals = sapply(confidence_level, function(conf_level) {
  sd_confidence(vii_marka_sd, n, conf_level);
});

# Create matrix
sd_confidence_intervals = t(sd_confidence_intervals);
rownames(sd_confidence_intervals) = paste0("Poziom ufności: ", confidence_level);
colnames(sd_confidence_intervals) = c("Dolny przedział", "Górny przedział");

# Display
print("Przedziały ufności odchylenia standardowego dla różnych poziomów ufności:");
print(sd_confidence_intervals);
print(paste("Wartość odchylenia standardowego z próby:", round(vii_marka_sd,2)));
```


# VIII - Testowanie hipotez
Testowanie hipotez w statystyce polega na weryfikacji, czy dane podtwierdzają
określoną hipotezę badawczą, przy jednoczesnym uwzględnieniu ryzyka popełnienia 
błędu. Procedura ta obejmuje sformułowanie hipotezy zerowej (H0) i 
alternatywnej (H1), obliczenie odpowiedniego testu, a następnie wyniku z 
wartością krytyczną, aby zdecydować o odrzuceniu lub nieodrzuceniu H0.


## Zmienne jakościowe

### Test niezależności 
Za pomocą testu niezależności $\chi^2$ sprawdzona zostanie niezależność pomiędzy 
Marką a udziałem w nich samochodów ze skrzynią mechaniczną.

Hipoteza:

$H_0$ - udział skrznyni mechanicznej jest niezależny od marki,

$H_1$ - udział skrznyni mechanicznej jest zależny od marki,

Poziom istotności $\alpha = 0.05$.

```{r}
vii_cross = table(database$Marka, database$SkrzyniaBiegowManualna)
vii_table = data.frame(Marka=rownames(vii_cross), UdzialSkrzyniManualnej = (vii_cross[,2]/(vii_cross[,1]+vii_cross[,2]))*100)

ggplot(vii_table, aes(y=Marka, x=UdzialSkrzyniManualnej)) + 
    geom_bar(position="dodge", stat="identity", fill="orange")+
    ggtitle("Udział samochodów z skrzynią manualną")

chisq.test(vii_cross)
```
Zgodnie z wynikiem testu mamy podstawy do odrzucenia hipotezy zerowej na korzyść 
hipotezy alternatywnej - udział skrznyni mechanicznej jest zależny od marki.

### Test proporcji
Test proporcji pozwala odpowiedzieć na pytanie czy odsetki w jednej, 
dwóch lub więcej grupach różnią się od siebie istotnie. 

Hipoteza:

$H_0$ - odsetek pojazdów uszkodzonych jest niezależny od kraju pochodzenia,

$H_1$ - odsetek pojazdów uszkodzonych jest zależny od kraju pochodzenia,

Poziom istotności $\alpha = 0.05$.
```{r}
vii_proporcja = database %>% group_by(KrajPochodzenia) %>% summarise(Liczebnosc = n());
vii_proporcja$Uszkodzonych = table(database$KrajPochodzenia, database$PojazdUszkodzony)[,2];
vii_proporcja$ProcentUszkodzonych = (vii_proporcja$Uszkodzonych / vii_proporcja$Liczebnosc) * 100;
vii_proporcja = vii_proporcja %>% filter(Liczebnosc > 1000);

ggplot(vii_proporcja, aes(y=KrajPochodzenia, x=ProcentUszkodzonych)) + 
    geom_bar(position="dodge", stat="identity", fill="orange")+
    ggtitle("Procent pojazdów uszkodzonych")

vii_test = prop.test(x = vii_proporcja$Uszkodzonych, n = vii_proporcja$Liczebnosc);
print(vii_test);
```
Zgodnie z wynikiem testu mamy podstawy do odrzucenia hipotezy zerowej na korzyść 
hipotezy alternatywnej -  odsetek pojazdów uszkodzonych jest zależny od kraju pochodzenia.

## Zmienne ilościowe

### Test normalności 
Test umożliwia weryfikację czy cecha ma rozkłada normalny.

Hipoteza:

$H_0$ - cena pojazdów ma rozkład normalny,

$H_1$ - cena pojazdów nie ma rozkładu normalnego,

Poziom istotności $\alpha = 0.05$.
```{r}
vii_test = ad.test(database$CenaPLN);
print(vii_test);
ggplot(database, aes(sample = CenaPLN)) +
  stat_qq() +
  stat_qq_line(color="red");
```
Zgodnie z wynikiem testu mamy podstawy do odrzucenia hipotezy zerowej na korzyść 
hipotezy alternatywnej - cena pojazdów nie ma rozkładu normalnego.
Jak można zaobserwować na wykresie QQ - zmienna odbiega od rozkładu normalnego.

### Test średnich
Ze względu na to, iż cena nie jest zmienną o rozkładzie normalnym. 
Wykorzystujemy nieparametryczny test Wilcoxona.

Hipoteza:

$H_0$ - średnia jest równa 41000,

$H_1$ - średnia nie jest równa 41000,

Poziom istotności $\alpha = 0.05$.
```{r}
wilcox.test(x = database$CenaPLN, mu = 41000)
```
Zgodnie z wynikiem testu mamy podstawy do odrzucenia hipotezy zerowej na korzyść 
hipotezy alternatywnej - średnia nie jest równa 41000.

# IX - Regresja liniowa oraz drzewa decyzyjna

## Modele dla jednej zmiennej
Regresja liniowa umożliwia badanie zależności między zmienną zależną a 
zmiennymi niezależnymi. Po określeniu modelu, funkcja zwraca szczegółowe 
podsumowanie zawierające oszacowania współczynników, testy istotności.
```{r, message = FALSE}
ix_database = select(filter(database, PojazdUszkodzony==FALSE & SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "PrzebiegKm"))
model = lm(CenaPLN ~ . , data = ix_database)
ix_sample = ix_database[sample(nrow(ix_database), size=1000),]
plot(CenaPLN ~ PrzebiegKm,  data=ix_sample, col = 'darkcyan')
abline(model, col="red")

summary(model);
print(model$coefficients);
```
W wyniki regresji uzyskano wzór: $CenaPLN  \approx -0.1115 PrzebigKM + 43817.4573$.


## Modele dla 2 zmiennych
UWAGA! - Wykres nie jest widoczny w pliku .pdf

Do regresji dla dwuch zmiennych wykorzystano tylko pojazdy nieuszkodzone z 
manualną skrzynią biegów, dla których wybrano następujące cechy 
*PrzebiegKm* oraz *PojemnoscSkokowa*.

```{r, message = FALSE, rgl = TRUE}
ix_database = select(filter(database, PojazdUszkodzony==FALSE & 
                                      SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "PrzebiegKm", "PojemnoscSkokowa"))
model = lm(CenaPLN ~ . , data = ix_database)

plot3d(model, col='darkcyan', plane.col = 'red')
rglwidget()

summary(model);
print(model$coefficients);
```
W wyniki regresji uzyskano wzór: $CenaPLN  \approx -0.1597 PrzebiegKm + 31.8533893 PojemnoscSkokowa -5537.7325$.

## Drzewa decyzyjne

Drzewo decyzyjne to struktura drzewiasta, gdzie każdy węzeł wewnętrzny 
reprezentuje test na pewnej zmiennej, każda gałąź reprezentuje wynik testu,
a każdy liść reprezentuje decyzję lub wartość przewidywaną.

Proces budowy drzewa decyzyjnego polega na rekurencyjnym dzieleniu zbioru
danych na podzbiory, które stają się coraz bardziej jednorodne pod względem 
zmiennej docelowej. 

Drzewa decyzyjne wykorzystane zostaną do analizy czynników wpływających na cenę 
sprzedaży. Do nauki wykorzystano tylko pojazdy nieuszkodzone z manualną skrzynią 
biegów, dla których wybrano następujące cechy *RokProdukcji*, *KM* oraz *PrzebiegKm*.

```{r, message = FALSE}
ix_database = select(filter(database, PojazdUszkodzony==FALSE & 
                                      SkrzyniaBiegowManualna == TRUE), 
                     c("CenaPLN", "RokProdukcji", "KM", "PrzebiegKm"))
ix_data_split = initial_split(ix_database, prop = 0.75);
ix_train_data <- training(ix_data_split);
ix_test_data <- testing(ix_data_split);

tree_spec <- decision_tree() %>%
 set_engine("rpart") %>%
 set_mode("regression")

tree_fit <- tree_spec %>%
 fit(CenaPLN ~ ., data = ix_train_data)

predictions <- tree_fit %>%
 predict(ix_test_data) %>%
 pull(.pred)

metrics <- metric_set(rmse, rsq)
model_performance <- ix_test_data %>%
 mutate(predictions = predictions) %>%
 metrics(truth = CenaPLN, estimate = predictions)

print(model_performance)

rpart.plot(tree_fit$fit, type = 5, extra = 101, under = TRUE, cex = 0.8, 
           box.palette = "auto", roundint=FALSE)
```
Jak można zaobserwować, głównymi czynnikami determinującymi cenę są 
*RokProdukcji* -> *KM* -> *PrzebiegKM*.